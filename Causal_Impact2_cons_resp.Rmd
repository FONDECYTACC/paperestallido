---
title: "Dataset Consolidation"
output:
  html_document: 
    code_folding: hide
    fig_height: 6
    fig_width: 8
    theme: spacelab
    toc: yes
    toc_depth: 6
    toc_float: yes
    number_sections: yes
---

```{=html}
<style type="text/css">
.tablelines table, .tablelines td, .tablelines th {
  border: 1px solid black;
  }
.centrado {
  text-align: center;
}
.table.center {
  margin-left:auto; 
  margin-right:auto;
}
.table_wrapper{
  display: block;
  overflow-x: auto;
  white-space: nowrap;
}
code.r{
  font-size: 8px;
}
body{ /* Normal  */
    text-align: justify;
}
.superbigimage{
  overflow-y:scroll;
  white-space: nowrap;
}
.superbigimage img{
  overflow-y: scroll;
  overflow-x: hidden;
}
p.comment {
  background-color: #FF7F79;
    padding: 10px;
  border: 1px solid black;
  margin-left: 25px;
  border-radius: 5px;
  font-style: italic;
}
</style>
```
```{=html}
<style>
  p.comment {
    background-color: #ff9a9a;
      padding: 10px;
    border: 1px solid red;
    margin-left: 25px;
    border-radius: 5px;
    font-style: italic;
  }

</style>
```
```{r setup0, include=T}
rm(list=ls());gc()
unlink('Causal_Impact2_cons_resp_cache', recursive = TRUE)

load(paste0(getwd(),"/","Procesos hasta 4_2.RData"))
#xaringan::inf_mr()

if(isTRUE(getOption('knitr.in.progress'))==T){
    clus_iter=30000
} else {
  input <- readline('¿Are you gonna run the dataset with the whole iterations? (Si/No): ')
  if(input=="Si"){
    clus_iter=10000
  } else {
    clus_iter=1000
  }
}
```

```{r setup, include=T, message=F, warning=F}
#arriba puse algunas opciones para que por defecto escondiera el código
#también cargue algunos estilo .css para que el texto me apareciera justificado, entre otras cosas.
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})

`%>%` <- magrittr::`%>%`
copy_names <- function(x,row.names=FALSE,col.names=TRUE,dec=",",...) {
  if(class(ungroup(x))[1]=="tbl_df"){
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)    
        }
  } else {
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)       
  }
 }
}  

if(!require(pacman)){install.packages("pacman")}

pacman::p_unlock(lib.loc = .libPaths()) #para no tener problemas reinstalando paquetes
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
#dejo los paquetes estadísticos que voy a utilizar

if(!require(plotly)){install.packages("plotly")}
if(!require(lubridate)){install.packages("lubridate")}
if(!require(htmlwidgets)){install.packages("htmlwidgets")}
if(!require(tidyverse)){install.packages("tidyverse")}
if(!require(gganimate)){install.packages("gganimate")}
if(!require(readr)){install.packages("readr")}
if(!require(stringr)){install.packages("stringr")}
if(!require(data.table)){install.packages("data.table")}
if(!require(DT)){install.packages("DT")}
if(!require(ggplot2)){install.packages("ggplot2")}
if(!require(lattice)){install.packages("lattice")}
if(!require(forecast)){install.packages("forecast")}
if(!require(zoo)){install.packages("zoo")}
if(!require(panelView)){install.packages("panelView")}
if(!require(janitor)){install.packages("janitor")}
if(!require(rjson)){install.packages("rjson")}
if(!require(estimatr)){install.packages("estimatr")} 
if(!require(CausalImpact)){install.packages("CausalImpact")}
if(!require(textreg)){install.packages("textreg")}
if(!require(sjPlot)){install.packages("sjPlot")}
if(!require(foreign)){install.packages("foreign")}
if(!require(tsModel)){install.packages("tsModel")}
if(!require(lmtest)){install.packages("lmtest")}
if(!require(Epi)){install.packages("Epi")}
if(!require(splines)){install.packages("splines")}
if(!require(vcd)){install.packages("vcd")}
if(!require(astsa)){install.packages("astsa")}
if(!require(forecast)){install.packages("forecast")}
if(!require(MASS)){install.packages("MASS")}
if(!require(ggsci)){install.packages("ggsci")}
if(!require(Hmisc)){install.packages("Hmisc")}
if(!require(compareGroups)){install.packages("compareGroups")}
if(!require(dplyr)){install.packages("dplyr")}
if(!require(ggforce)){install.packages("ggforce")}
if(!require(imputeTS)){install.packages("imputeTS")}
if(!require(doParallel)){install.packages("doParallel")}
if(!require(SCtools)){install.packages("SCtools")}
if(!require(MSCMT)){install.packages("MSCMT")}
# Calculate the number of cores
no_cores <- detectCores() - 1
cl<-makeCluster(no_cores)
registerDoParallel(cl)

Sys.setlocale(category = "LC_ALL", locale = "english")
```

```{r setting_prev_a, echo=T, cache= T, paged.print=TRUE, warning=F, eval=T}
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#
######1. Ejemplo 1 #####
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

#PARÁMETROS INGRESADOS A LOS MODELOS POR THOMAS
#cons_trauma ~ offset(log(offset)) + year + as.Date(date) + month + day + weekday + yearday + prevtrc + difftrc + hosp_trauma,
#hosp_trauma ~ offset(log(offset)) + year + as.Date(date) + month + day + weekday + yearday + prevtrh + difftrh + cons_trauma,
#data15a64[data15a64$tx == 0 & data15a64$txtime == 0, ]
#glm(hosp_trauma ~ hosp_circ + year + month + day + weekday + yearday + prevtrh, family = quasipoisson(), data15a64[data15a64$tx == 0 & data15a64$txtime == 1,])
#glm(hosp_trauma ~ hosp_circ + year + month + day + weekday + yearday + prevtrh, family = poisson(), data15a64[data15a64$tx == 0 & data15a64$txtime == 1,])
#lm(hosp_trauma ~ hosp_circ + year + month + day + weekday + yearday + prevtrh, data15a64[data15a64$tx == 0 & data15a64$txtime == 1,])

#Genero una columna conteo por fila
data15a64_rn<- data15a64_wk%>% dplyr::mutate(rn=row_number())
data65a_rn<-  data15a64_wk%>% dplyr::mutate(rn=row_number())

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#

rn_summ_data15a64<-
data15a64_rn%>%
    dplyr::filter(did==1)%>%
    dplyr::summarise(min=min(rn),max=max(rn),diff=max-min)
post.period <- c(as.numeric(rn_summ_data15a64["min"]), as.numeric(rn_summ_data15a64["max"]))
```

<br>

# Bayesian Structural Time-Series

<br>

In order to reproduce adequately what was solicited, we looked over the models Thomas did. The independent variables we selected were: - Circulatory Consultations (`cons_circ`) - Trauma Consultations (`cons_trauma`) - Year, month, day, weekday, yearday - Difference Between Total Hospitalizations and Respiratory Hospitalizations (`diffreh`).

<br>

The model of Bayesian Structural Time Series (BSTS) with Causal Impact Analysis contains a local level component (observation equation linking observed data to a state vector) and a seasonal component (state equation that describes how the state vector evolves over time). Also it can contain other predictor series. The method uses a Markov chain Monte Carlo (MCMC) sampling of the structural time series given the observed data and the priors.

<br>

```{=html}
<!--- 
modelA <- lm(hosp_resp ~ hosp_circ + year + month + day + weekday + yearday + prevreh, data15a64[data15a64$tx == 0 & data15a64$txtime == 0,])
modelB <- glm(hosp_resp ~ hosp_circ + year + month + day + weekday + yearday + prevreh, family = poisson, data15a64[data15a64$tx == 0 & data15a64$txtime == 0,])
modelC <- glm(hosp_resp ~ hosp_circ + year + month + day + weekday + yearday + prevreh, family = quasipoisson, data15a64[data15a64$tx == 0 & data15a64$txtime == 0,])
modelD <- nb(hosp_resp ~ offset(log(offset)) + year + as.Date(date) + month + day + weekday + yearday + prevreh + diffreh + cons_resp,
    data15a64[data15a64$tx == 0 & data15a64$txtime == 0, ])
    
attr(data15a64_wk$prevtrc, "label") <- "Dependent Variable of Choice Prior Day Value of the Total Trauma Consultations"
attr(data15a64_wk$prevrec, "label") <-  "Dependent Variable of Choice Prior Day Value of the Total Respiratory Consultations"
attr(data15a64_wk$prevtrh, "label") <- "Dependent Variable of Choice Prior Day Value of the Total Trauma Hospitalizations"
attr(data15a64_wk$prevreh, "label") <- "Dependent Variable of Choice Prior Day Value of the Total Respiratory Hospitalizations"

attr(data15a64_wk$difftrc, "label") <- "Difference Between Total Consultations and the Total Trauma Consultations"
attr(data15a64_wk$difftrh, "label") <- "Difference Between Total Hospitalizations and the Total Trauma Hospitalizations"
attr(data15a64_wk$diffrec, "label") <-  "Difference Between Total Consultations and the Total Respiratory Consultations"
attr(data15a64_wk$diffreh, "label") <- "Difference Between Total Hospitalizations and the Total Respiratory Hospitalizations"
attr(data15a64_wk$offset, "label") <- "Sum of the total consultations and total hospitalizations"
--->
```
## Several models contrasted

We decided to contrast several models with different specifications and control variables. We started with a model that did not have a counterfactual.

<br>

### No counterfactual, no control variables

```{r bsts1, echo=T, cache= T, paged.print=TRUE, warning=F}
library(CausalImpact)

data15a64_rn2<-
data15a64_rn%>%
  dplyr::mutate(log_offset=log(offset))%>%
  dplyr::mutate(log_cons_trauma=log(cons_trauma))%>%
  dplyr::mutate(log_cons_circ=log(cons_circ))%>%
  dplyr::mutate(log_cons_resp=log(cons_resp))%>%
  dplyr::mutate(log_diffreh=log(diffreh))%>%
  data.frame()
  
#rn_summ_data15a64

#CREATE THE DB --> SUPER IMPORTANT TO ADD THE OUTPUT OF INTEREST AS THE FIRST COLUMN here, plus to select all the other time series we want:
#in this case we take all the columns from 2 to 10
df <- zoo(data15a64_rn2[c("cons_resp","cons_circ","cons_trauma","diffreh")], as.Date(data15a64_rn2$date)) #prevtrh had a missing value due to the absence of previous value
#set the period before intervention
pre.period <- as.Date(c("2015-01-05", "2019-10-14"))
#set the period after intervention
post.period <- as.Date(c("2019-10-21", "2019-12-23"))
#compute CausalImpact, look at the documentation to change niter and nseasons
set.seed(2125)
impact <- CausalImpact(df, pre.period,post.period, model.args=list(niter=clus_iter, nseasons=7))
plot(impact, "original") 

plot(impact)
##summary(impact) 
##summary(impact,"report")
```

<br>

### With counterfactuals

We decided to exclude the post-treatment period data to specify our model, to mimic the fact that this data should be unobserved after the intervention. We introduced yearly and monthly seasonal components into the time-series structure. We started with a Random Walk. This local level model assumes the trend is a random walk (do not assume an observable pattern or trend).

<br>

```{r bsts2, echo=T, cache= T, paged.print=TRUE, warning=F}
###RANDOM WALK
#######https://magoosh.com/statistics/what-is-random-walk-theory/
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

##data%>% dplyr::filter(yearday>0)%>% group_by(year)%>% summarise(min(as.Date(date)),max(as.Date(date)),n())

#I will explore their cumulative 1 step forward prediction error for the time series between the start to the time of intervention
# Post Intervention Period is filled with NA
# Remove outcomes from the post-period. The BSTS model should be ignorant of the values we intend to predict

#_#_#_#_#_#_#_#_#_#_#_#_#_
#MADE WITH VECTORS: https://rpubs.com/irJERAD/Causal-Impact
#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#c("log_cons_resp","log_cons_circ","log_cons_trauma","log_diffreh")
data15a64_rn_causal <- data15a64_rn %>%
    dplyr::mutate(cons_resp = replace(cons_resp, did >= 1, NA)) %>% 
    dplyr::mutate(log_cons_resp=log(cons_resp))%>%
    dplyr::mutate(log_cons_circ=log(cons_circ))%>%
    dplyr::mutate(log_cons_trauma=log(cons_trauma))%>%
    dplyr::mutate(log_diffreh=log(diffreh))

post_period_response <- as.numeric(unlist(data15a64_rn[which(data15a64_rn$did==1),"cons_resp"]))

y<- data15a64_rn_causal$cons_resp
x1 <-data15a64_rn_causal$cons_circ
x2 <-data15a64_rn_causal$cons_trauma
x3 <-data15a64_rn_causal$diffreh
x4 <-data15a64_rn_causal$log_offset

#y<- data15a64_rn_causal$log_cons_resp
#x1 <-data15a64_rn_causal$log_cons_circ
#x2 <-data15a64_rn_causal$log_cons_trauma
#x3 <-data15a64_rn_causal$log_diffreh
#x4 <-data15a64_rn_causal$log_offset

# Model 1
ss <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss <- AddLocalLevel(ss, data15a64_rn_causal$cons_resp) #
# Add weekly seasonal
ss <- AddSeasonal(ss, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss <- AddSeasonal(ss, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration = 4) #months
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1 <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ss, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               #family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
plot(model1, main = "Model 1")
plot(model1, "components")

impact2 <- CausalImpact(bsts.model = model1,
                       post.period.response = post_period_response)
plot(impact2, "original") 

burn1 <- SuggestBurn(0.1, model1)

plot(impact2)
#summary(impact2) 
##summary(impact2,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2 <- AddLocalLevel(ss2, data15a64_rn_causal$cons_resp) #
# Add weekly seasonal
ss2 <- AddSeasonal(ss2, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2 <- AddSeasonal(ss2, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2 <- bsts(data15a64_rn_causal$cons_resp ~ x1, 
               state.specification = ss2, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               #family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
plot(model2, main = "Model 2")
plot(model2, "components")

impact3 <- CausalImpact(bsts.model = model2,
                       post.period.response = post_period_response)
plot(impact3, "original") 

burn2 <- SuggestBurn(0.1, model2)

plot(impact3)
#summary(impact3) 
##summary(impact3,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
```

<br>

### Local Linear Trend

A model with too many components can sometimes offer too much flexibility, providing unrealistically widening forecasts. This is why the default model does not include a local linear trend component [(see this link)](https://stats.stackexchange.com/questions/266129/causalimpact-model-in-the-paper-and-default-in-the-package/267170#267170). But in the next two models we assumed a local structure of the latent state variable (`AddLocalLinearTrend`), instead of a random process.

```{=html}
<!--- 
This model differs from the local linear trend model in that the latter assumes the slope  follows a random walk. A stationary AR(1) process is less variable than a random walk when making projections far into the future, so this model often gives more reasonable uncertainty estimates when making long term forecasts.
 
 This could be due to the fact that the drift component in the semi local linear trend comprised of more variables (D, ρ) that allowed for more extreme stochasticity. This allowed for the semi-local linear trend models to capture certain high spike points such as in Jan 2018 that were not captured by the trends in the local linear trend models.
--->

```
<br>

```{r bsts2b, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssb <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssb <- AddLocalLinearTrend(ssb, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel
# Add weekly seasonal
ssb <- AddSeasonal(ssb, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssb <- AddSeasonal(ssb, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years

# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1b <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssb, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               #family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data. NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1b, main = "Model 1")
plot(model1b, "components")

impact2b <- CausalImpact(bsts.model = model1b,
                       post.period.response = post_period_response)
plot(impact2b, "original") 

burn1b <- SuggestBurn(0.1, model1b)

plot(impact2b)
#summary(impact2b) 
##summary(impact2b,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3b, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2b <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2b <- AddLocalLinearTrend(ss2b, data15a64_rn_causal$cons_resp) #
# Add weekly seasonal
ss2b <- AddSeasonal(ss2b, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2b <- AddSeasonal(ss2b, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2b <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2b, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
              # family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2b, main = "Model 2")
plot(model2b, "components")

impact3b <- CausalImpact(bsts.model = model2b,
                       post.period.response = post_period_response)
plot(impact3b, "original") 

burn2b <- SuggestBurn(0.1, model2b)

plot(impact3b)
#summary(impact3b) 
##summary(impact3b,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

<br>

### Local Linear Trend & AR

<br>

We also introduced an a sparse AR(1) process to the state distribution.

<br>

```{r bsts2b_ar, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssb <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssb <- AddLocalLinearTrend(ssb, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel
ssb <- AddAutoAr(ssb,data15a64_rn_causal$cons_resp)

# Add weekly seasonal
ssb <- AddSeasonal(ssb, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssb <- AddSeasonal(ssb, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years

# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1bar <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssb, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               #family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data. NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1bar, main = "Model 1")
plot(model1bar, "components")

impact2bar <- CausalImpact(bsts.model = model1bar,
                       post.period.response = post_period_response)
plot(impact2bar, "original") 

burn1bar <- SuggestBurn(0.1, model1bar)

plot(impact2bar)
#summary(impact2b) 
##summary(impact2b,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3b_ar, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2b <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2b <- AddLocalLinearTrend(ss2b, data15a64_rn_causal$cons_resp) #
ss2b <- AddAutoAr(ss2b,data15a64_rn_causal$cons_resp)

# Add weekly seasonal
ss2b <- AddSeasonal(ss2b, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2b <- AddSeasonal(ss2b, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2bar <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2b, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
              # family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2bar, main = "Model 2")
plot(model2bar, "components")

impact3bar <- CausalImpact(bsts.model = model2b,
                       post.period.response = post_period_response)
plot(impact3bar, "original") 

burn2bar <- SuggestBurn(0.1, model2bar)

plot(impact3bar)
#summary(impact3b) 
##summary(impact3b,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

<br>

### Prior Local Level SD=.1 (more restrictive)

We used the term `prior.level.sd` to .1 instead of the default .01, which had been a typical choice for well-behaved and stable datasets with low residual volatility. We decided to distinguish between models that assumed a Random Walk structure, to local linear trends.

<br>

```{r bsts2c, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssc <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssc <- AddLocalLevel(ssc, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel
# Add weekly seasonal
ssc <- AddSeasonal(ssc, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssc <- AddSeasonal(ssc, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1c <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssc, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               #family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data. NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1c, main = "Model 1")
plot(model1c, "components")

impact2c <- CausalImpact(bsts.model = model1c,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact2c, "original") 

burn1c <- SuggestBurn(0.1, model1c)

plot(impact2c)
#summary(impact2c) 
##summary(impact2c,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3c, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2c <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2c <- AddLocalLevel(ss2c, data15a64_rn_causal$cons_resp) #
# Add weekly seasonal
ss2c <- AddSeasonal(ss2c, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2c <- AddSeasonal(ss2c, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2c <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2c, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
              # family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2c, main = "Model 2")
plot(model2c, "components")

impact3c <- CausalImpact(bsts.model = model2c,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact3c, "original") 

burn2c <- SuggestBurn(0.1, model2c)

plot(impact3c)
#summary(impact3c) 
##summary(impact3c,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

#### Prior Local SD=.1 (more restrictive) w/ Local Linear Trends

<br>

We changed the assumption of a random walk model to a local-linear trend to the structure of the series.

<br>

```{r bsts2c3, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssc3 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssc3 <- AddLocalLinearTrend(ssc3, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel
# Add weekly seasonal
ssc3 <- AddSeasonal(ssc3, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssc3 <- AddSeasonal(ssc3, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1c3 <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssc3, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               #family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data. NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1c3, main = "Model 1")
plot(model1c3, "components")

impact2c3 <- CausalImpact(bsts.model = model1c3,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact2c3, "original") 

burn1c3 <- SuggestBurn(0.1, model1c3)

plot(impact2c3)
#summary(impact2c) 
##summary(impact2c,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3c3, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2c3 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2c3 <- AddLocalLinearTrend(ss2c3, data15a64_rn_causal$cons_resp) #
# Add weekly seasonal
ss2c3 <- AddSeasonal(ss2c3, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2c3 <- AddSeasonal(ss2c3, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2c3 <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2c3, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
              # family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2c3, main = "Model 2")
plot(model2c3, "components")

impact3c3 <- CausalImpact(bsts.model = model2c3, model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact3c3, "original") 

burn2c3 <- SuggestBurn(0.1, model2c3)

plot(impact3c3)
#summary(impact3c) 
##summary(impact3c,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

#### Prior Local SD=.1 (more restrictive) w/ Local Linear Trends & AR

<br>

We also introduced an a sparse AR(1) process to the state distribution.

<br>

```{r bsts2c3_ar, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssc3 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssc3 <- AddLocalLinearTrend(ssc3, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel
ssc3 <- AddAutoAr(ssc3,data15a64_rn_causal$cons_resp)
# Add weekly seasonal
ssc3 <- AddSeasonal(ssc3, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssc3 <- AddSeasonal(ssc3, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1c3ar <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssc3, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               #family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data. NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1c3ar, main = "Model 1")
plot(model1c3ar, "components")

impact2c3ar <- CausalImpact(bsts.model = model1c3ar,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact2c3ar, "original") 

burn1c3ar <- SuggestBurn(0.1, model1c3ar)

plot(impact2c3ar)
#summary(impact2c) 
##summary(impact2c,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3c3_ar, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2c3 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2c3 <- AddLocalLinearTrend(ss2c3, data15a64_rn_causal$cons_resp) #
ss2c3 <- AddAutoAr(ss2c3,data15a64_rn_causal$cons_resp)
# Add weekly seasonal
ss2c3 <- AddSeasonal(ss2c3, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2c3 <- AddSeasonal(ss2c3, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2c3ar <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2c3, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
              # family ="poisson", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2c3ar, main = "Model 2")
plot(model2c3ar, "components")

impact3c3ar <- CausalImpact(bsts.model = model2c3ar, model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact3c3ar, "original") 

burn2c3ar <- SuggestBurn(0.1, model2c3ar)

plot(impact3c3ar)
#summary(impact3c) 
##summary(impact3c,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

### Studentized Distributed Noise (more restrictive)

<br>

The default model assumes a Gaussian noise and a Gaussian random walk. In order to handle outliers, we assumed studentized distributed noise.

<br>

```{r bsts2d, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssd <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssd <- AddLocalLevel(ssd, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel
# Add weekly seasonal
ssd <- AddSeasonal(ssd, data15a64_rn_causal$cons_resp,nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssd <- AddSeasonal(ssd, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1d1 <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssd, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data. POISSON NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1d1, main = "Model 1")
plot(model1d1, "components")

impact2d1 <- CausalImpact(bsts.model = model1d1,
                       post.period.response = post_period_response)
plot(impact2d1, "original") 

burn1d1 <- SuggestBurn(0.1, model1d1)

plot(impact2d1)
#summary(impact2d1) 
##summary(impact2d1,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3d, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2d <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2d <- AddLocalLevel(ss2d, data15a64_rn_causal$cons_resp) #
# Add weekly seasonal
ss2d <- AddSeasonal(ss2d, data15a64_rn_causal$cons_resp,nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2d <- AddSeasonal(ss2d, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2d1 <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2d, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2d1, main = "Model 2")
plot(model2d1, "components")

impact3d1 <- CausalImpact(bsts.model = model2d1,
                       post.period.response = post_period_response)
plot(impact3d1, "original") 

burn2d1 <- SuggestBurn(0.1, model2d1)

plot(impact3d1)
#summary(impact3d1) 
##summary(impact3d1,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

##### Studentized Distributed Noise w/ Local Linear Trends

<br>

```{r bsts2d22, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssd <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssd <- AddLocalLinearTrend(ssd, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel
# Add weekly seasonal
ssd <- AddSeasonal(ssd, data15a64_rn_causal$cons_resp,nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssd <- AddSeasonal(ssd, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1d2 <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssd, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data. POISSON NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1d2, main = "Model 1")
plot(model1d2, "components")

impact2d2 <- CausalImpact(bsts.model = model1d2,
                       post.period.response = post_period_response)
plot(impact2d2, "original") 

burn1d2 <- SuggestBurn(0.1, model1d2)

plot(impact2d2)
#summary(impact2d1) 
##summary(impact2d1,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3d22, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2d <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2d <- AddLocalLinearTrend(ss2d, data15a64_rn_causal$cons_resp) #
# Add weekly seasonal
ss2d <- AddSeasonal(ss2d, data15a64_rn_causal$cons_resp,nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2d <- AddSeasonal(ss2d, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2d2 <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2d, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2d2, main = "Model 2")
plot(model2d2, "components")

impact3d2 <- CausalImpact(bsts.model = model2d2,
                       post.period.response = post_period_response)
plot(impact3d2, "original") 

burn2d2 <- SuggestBurn(0.1, model2d2)

plot(impact3d2)
#summary(impact3d1) 
##summary(impact3d1,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

<br>

##### Studentized Distributed Noise w/ Local Linear Trends & AR

<br>

We also introduced an a sparse AR(1) process to the state distribution.

<br>s

```{r bsts2d22_ar, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssd <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssd <- AddLocalLinearTrend(ssd, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel
ssd <- AddAutoAr(ssd,data15a64_rn_causal$cons_resp)

# Add weekly seasonal
ssd <- AddSeasonal(ssd, data15a64_rn_causal$cons_resp,nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssd <- AddSeasonal(ssd, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1d2ar <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssd, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data. POISSON NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1d2ar, main = "Model 1")
plot(model1d2ar, "components")

impact2d2ar <- CausalImpact(bsts.model = model1d2ar,
                       post.period.response = post_period_response)
plot(impact2d2ar, "original") 

burn1d2ar <- SuggestBurn(0.1, model1d2ar)

plot(impact2d2ar)
#summary(impact2d1) 
##summary(impact2d1,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3d22_ar, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2d <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2d <- AddLocalLinearTrend(ss2d, data15a64_rn_causal$cons_resp)
ss2d <- AddAutoAr(ss2d,data15a64_rn_causal$cons_resp)
#
# Add weekly seasonal
ss2d <- AddSeasonal(ss2d, data15a64_rn_causal$cons_resp,nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2d <- AddSeasonal(ss2d, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2d2ar <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2d, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2d2ar, main = "Model 2")
plot(model2d2ar, "components")

impact3d2ar <- CausalImpact(bsts.model = model2d2ar,
                       post.period.response = post_period_response)
plot(impact3d2ar, "original") 

burn2d2ar <- SuggestBurn(0.1, model2d2ar)

plot(impact3d2ar)
#summary(impact3d1) 
##summary(impact3d1,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

<br>

#### Studentized Distributed Noise w/ Priors SD=.1 (more restrictive)

<br>

For the following models, we used a prior SD of .1

<br>

```{r bsts2d2, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssd <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssd <- AddLocalLevel(ssd, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel AddLocalLinearTrend
# Add weekly seasonal
ssd <- AddSeasonal(ssd, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssd <- AddSeasonal(ssd, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1d <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssd, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data. POISSON NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model1d, main = "Model 1")
plot(model1d, "components")

impact2d <- CausalImpact(bsts.model = model1d,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact2d, "original") 

burn1d <- SuggestBurn(0.1, model1d)

plot(impact2d)
#summary(impact2d) 
##summary(impact2d,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3d2, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2d <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2d <- AddLocalLevel(ss2d, data15a64_rn_causal$cons_resp) #
# Add weekly seasonal
ss2d <- AddSeasonal(ss2d, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2d <- AddSeasonal(ss2d, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2d <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2d, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2d, main = "Model 2")
plot(model2d, "components")

impact3d <- CausalImpact(bsts.model = model2d,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact3d, "original") 

burn2d <- SuggestBurn(0.1, model2d)

plot(impact3d)
#summary(impact3d) 
##summary(impact3d,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

#### Studentized Distributed Noise w/ Priors SD=.1 (more restrictive) w/ Local Linear Trends

<br>

For the following models, we used a prior SD of .1 and a Local Linear Trend.

<br>

```{r bsts2d3, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssd3 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssd3 <- AddLocalLinearTrend(ssd3, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel AddLocalLinearTrend
#ssd3 <- AddAutoAr(ssd3,data15a64_rn_causal$hosp_trauma)
# Add weekly seasonal
ssd3 <- AddSeasonal(ssd3, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssd3 <- AddSeasonal(ssd3, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1d3 <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssd3, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data. POISSON NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)

burn1d3 <- SuggestBurn(0.1, model1d3)
#,
#               dynamic.regression=T)
plot(model1d3, main = "Model 1")
plot(model1d3, "components")

#pred <- predict(model1d3, horizon = 9, burn =burn1d3)
#updated.pred <- predict(model1d3, horizon = 9, olddata = data15a64_rn_causal$hosp_trauma)

impact2d3 <- CausalImpact(bsts.model = model1d3,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact2d3, "original") 

plot(impact2d3)
#summary(impact2d3) 
##summary(impact2d3,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3d3, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2d3 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2d3 <- AddLocalLinearTrend(ss2d3, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel AddLocalLinearTrend
#ss2d3 <- AddAutoAr(ss2d3,data15a64_rn_causal$cons_resp)
# Add weekly seasonal
ss2d3 <- AddSeasonal(ss2d3, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2d3 <- AddSeasonal(ss2d3, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2d3 <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2d3, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2d3, main = "Model 2")
plot(model2d3, "components")

impact3d3 <- CausalImpact(bsts.model = model2d3,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact3d3, "original") 

burn2d3 <- SuggestBurn(0.1, model2d3)

plot(impact3d3)
#summary(impact3d3) 
##summary(impact3d3,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

<br>

#### Studentized Distributed Noise w/ Priors SD=.1 (more restrictive) w/ Local Linear Trends & AR

<br>

We also introduced an a sparse AR(1) process to the state distribution.

<br>s

```{r bsts2d3_ar, echo=T, cache= T, paged.print=TRUE, warning=F}
# Model 1
ssd3 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ssd3 <- AddLocalLinearTrend(ssd3, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel AddLocalLinearTrend
ssd3 <- AddAutoAr(ssd3,data15a64_rn_causal$cons_resp)
# Add weekly seasonal
ssd3 <- AddSeasonal(ssd3, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ssd3 <- AddSeasonal(ssd3, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model1d3ar <- bsts(data15a64_rn_causal$cons_resp, 
               state.specification = ssd3, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data. POISSON NO SE PUEDE OCUPAR
               niter = clus_iter, 
               #burn = 200, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)

burn1d3ar <- SuggestBurn(0.1, model1d3ar)
#,
#               dynamic.regression=T)
plot(model1d3ar, main = "Model 1")
plot(model1d3ar, "components")

#pred <- predict(model1d3, horizon = 9, burn =burn1d3)
#updated.pred <- predict(model1d3, horizon = 9, olddata = data15a64_rn_causal$hosp_trauma)

impact2d3ar <- CausalImpact(bsts.model = model1d3ar,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact2d3ar, "original") 

plot(impact2d3ar)
#summary(impact2d3) 
##summary(impact2d3,"report")
#msts(data15a64_rn$hosp_trauma, seasonal.periods=c(7,365.25))
```

```{r bsts3d3_ar, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T}
#The response variable (i.e., the first column in data) may contain missing values (NA), but covariates (all other columns in data) may not. If one of your covariates contains missing values, consider imputing (i.e., estimating) the missing values; if this is not feasible, leave the regressor out.

# Model 2
ss2d3 <- list()
# Local trend, weekly-seasonal #https://qastack.mx/stats/209426/predictions-from-bsts-model-in-r-are-failing-completely - PUSE UN GENERALIZED LOCAL TREND
ss2d3 <- AddLocalLinearTrend(ss2d3, data15a64_rn_causal$cons_resp) #AddSemilocalLinearTrend #AddLocalLevel AddLocalLinearTrend
ss2d3 <- AddAutoAr(ss2d3,data15a64_rn_causal$cons_resp)
# Add weekly seasonal
ss2d3 <- AddSeasonal(ss2d3, data15a64_rn_causal$cons_resp, nseasons=5, season.duration = 52) #weeks OJO, ESTOS NO SON WEEKS VERDADEROS. PORQUE TENGO MAS DE EUN AÑO
ss2d3 <- AddSeasonal(ss2d3, data15a64_rn_causal$cons_resp, nseasons = 12, season.duration =4) #years
#ss2 <- AddAutoAr(ss2, y = data15a64_rn_causal$hosp_trauma, lags = 1) #NO PUEDO AREGAR AR1 CON POISSON
# For example, to add a day-of-week component to data with daily granularity, use model.args = list(nseasons = 7, season.duration = 1). To add a day-of-week component to data with hourly granularity, set model.args = list(nseasons = 7, season.duration = 24).
model2d3ar <- bsts(data15a64_rn_causal$cons_resp ~ x1,
               state.specification = ss2d3, #A list with elements created by AddLocalLinearTrend, AddSeasonal, and similar functions for adding components of state. See the help page for state.specification.
               family ="student", #A Bayesian Analysis of Time-Series Event Count Data
               niter = clus_iter, 
              # burn = 500, #http://finzi.psych.upenn.edu/library/bsts/html/SuggestBurn.html Suggest the size of an MCMC burn in sample as a proportion of the total run.
               seed= 2125)
#,
#               dynamic.regression=T)
plot(model2d3ar, main = "Model 2")
plot(model2d3ar, "components")

impact3d3ar <- CausalImpact(bsts.model = model2d3ar,model.args = list(prior.level.sd=.1),
                       post.period.response = post_period_response)
plot(impact3d3ar, "original") 

burn2d3 <- SuggestBurn(0.1, model2d3ar)

plot(impact3d3ar)
#summary(impact3d3) 
##summary(impact3d3,"report")
#dynamic.regression Whether to include time-varying regression coefficients. In combination with a time-varying local trend or even a time-varying local level, this often leads to overspecification, in which case a static regression is safer. Defaults to FALSE.
#
#Prior standard deviation of the Gaussian random walk of the local level. Expressed in terms of data standard deviations. Defaults to 0.01, a typical choice for well-behaved and stable datasets with low residual volatility after regressing out known predictors (e.g., web searches or sales in high quantities). When in doubt, a safer option is to use 0.1, as validated on synthetic data, although this may sometimes give rise to unrealistically wide prediction intervals.
```

<br>

------------------------------------------------------------------------

## Comparison Between Models

<br>

We compared the models selected in terms of cumulative absolute error.

<br>

```{r comp_models_prev, echo=T, cache= T, paged.print=TRUE, warning=F,eval=T,fig.show='hide', fig.height=14}
comp_mod<-CompareBstsModels(list("No control variables(a)" = model1,
                                "Control variables(b)" = model2,
                                "a, LocalLinearTrend" = model1b,
                                "b, LocalLinearTrend" = model2b,
                                "a, LocalLinearTrend & AR" = model1bar,
                                "b, LocalLinearTrend & AR" = model2bar,
                                "a, Prior sd=.1" = model1c,
                                "b, Prior sd=.1" = model2c,
                                "a, Prior sd=.1,LocalLinearTrend" = model1c3,
                                "b, Prior sd=.1,LocalLinearTrend" = model2c3,
                                "a, Prior sd=.1,LocalLinearTrend & AR" = model1c3ar,
                                "b, Prior sd=.1,LocalLinearTrend & AR" = model2c3ar,
                                "a, Student Dist, Prior sd=.01" = model1d1, #Student SD=.1 Local
                                "b, Student Dist, Prior sd=.01" = model2d1, #Student SD=.1 Local
                                "a, Student Dist, Prior sd=.01, LocalLinearTrend" = model1d2,
                                "b, Student Dist, Prior sd=.01, LocalLinearTrend" = model2d2,
                                "a, Student Dist, Prior sd=.01, LocalLinearTrend & AR" = model1d2ar,
                                "b, Student Dist, Prior sd=.01, LocalLinearTrend & AR" = model2d2ar,
                                "a, Student Dist, Prior sd=.1" = model1d,
                                "b, Student Dist, Prior sd=.1" = model2d,
                                "a, Student Dist, Prior sd=.1, LocalLinearTrend" = model1d3,
                                "b, Student Dist, Prior sd=.1, LocalLinearTrend" = model2d3,
                                "a, Student Dist, Prior sd=.1, LocalLinearTrend & AR" = model1d3ar,
                                "b, Student Dist, Prior sd=.1, LocalLinearTrend & AR" = model2d3ar
                       ),
                  colors = c("black", "red", "blue","purple","gray","darkslategrey","darkslateblue","darkorange3","forestgreen",
                             "yellow","pink", "brown","cyan"))
```

```{r comp_models, echo=T, cache= T, paged.print=TRUE, warning=F, eval=T, fig.align='center', fig.cap= "Figure 9. Comparison of BSTS models (cum. error)"}
scale2 <- function(x, na.rm = FALSE) (x - mean(x, na.rm = na.rm)) / sd(x, na.rm)

comp_mod_df<-
data.frame(cbind(Models=c("No control variables(a)",
                          "Control variables(b)",
                          "a, LocalLinearTrend",
                          "b, LocalLinearTrend",
                          "a, LocalLinearTrend & AR",
                          "b, LocalLinearTrend & AR",                          
                          "a, Prior sd=.1",
                          "b, Prior sd=.1",
                          "a, Prior sd=.1, LocalLinearTrend",
                          "b, Prior sd=.1, LocalLinearTrend",
                          "a, Prior sd=.1, LocalLinearTrend & AR",
                          "b, Prior sd=.1, LocalLinearTrend & AR",
                          "a, Student Dist, Prior sd=.01",
                          "b, Student Dist, Prior sd=.01",
                          "a, Student Dist, Prior sd=.01, LocalLinearTrend",
                          "b, Student Dist, Prior sd=.01, LocalLinearTrend",
                          "a, Student Dist, Prior sd=.01, LocalLinearTrend & AR",
                          "b, Student Dist, Prior sd=.01, LocalLinearTrend & AR",
                          "a, Student Dist, Prior sd=.1",
                          "b, Student Dist, Prior sd=.1",
                          "a, Student Dist, Prior sd=.1, LocalLinearTrend",
                          "b, Student Dist, Prior sd=.1, LocalLinearTrend",
                          "a, Student Dist, Prior sd=.1, LocalLinearTrend & AR",
                          "b, Student Dist, Prior sd=.1, LocalLinearTrend & AR"),
                 comp_mod)) %>%  #16
  melt(id=1)%>%
  dplyr::rename("Time"="variable") %>% 
  dplyr::rename("Cumulative Absolute Error"="value") %>% 
  dplyr::mutate(Time=as.numeric(sub('V', '', Time))) %>% 
  dplyr::mutate(`Cumulative Absolute Error`=as.numeric(`Cumulative Absolute Error`)) %>% 
  dplyr::mutate(text=paste0("CAFE= ",sprintf("%4.0f",`Cumulative Absolute Error`),"\n","Time= ",Time,"\n",
                            Models))

ggplotcomp_models<-    
ggplot(comp_mod_df)+
  #geom_point(color="white")+
    geom_line(size=.75, aes(x = Time, y = `Cumulative Absolute Error`, color=Models,group=Models, text=text))+
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  scale_fill_brewer(type="seq", palette="Greys")+
  theme_sjplot2()+
  theme(axis.text.y=element_blank(),
                    axis.text.x =  element_text(angle = 0, hjust = 1),
                    axis.ticks.y=element_blank(),                    
                    panel.grid.major.y=element_blank(),
        #panel.grid.major.x=element_blank(),
        panel.grid.minor.x=element_blank())+
  theme(legend.position='none')+
  scale_x_continuous(breaks=seq(from =1,to =max(comp_mod_df$Time)+4,by=12))+
  labs(x="Time (in weeks)", y= "Cumulative Absolute Forecast Error (CAFE)")

ggplotly(ggplotcomp_models,tooltip="text")

comp_mod_df_sum<-
comp_mod_df %>% group_by(Models) %>% summarise(mean=mean(abs(`Cumulative Absolute Error`),na.rm=T),median=median(abs(`Cumulative Absolute Error`),na.rm=T), p25=quantile(abs(`Cumulative Absolute Error`),.25,na.rm=T),p75=quantile(abs(`Cumulative Absolute Error`),.75,na.rm=T), max=max(`Cumulative Absolute Error`,na.rm=T)) %>%
  dplyr::mutate(mean=scale2(mean),median=scale2(median),p25=scale2(p25),p75=scale2(p75)) %>% 
  rowwise() %>%
  mutate(mean_tot = mean(c(mean,median,p25,p75))) %>% 
  dplyr::arrange(mean_tot)
  #geom_line(aes(x=Models,y=median),color="blue")+
  #geom_line(aes(x=Models,y=p25),color="green")


#impact "No counterfactual approach, No seasonal components" "Counterfactual Approach, NoSeasonal Components (impact2)" (b= SemilocalLinearTrend) (c=Gaussian, prior sd=.01) (d1= Student, Prior sd .01) (d= Student, Prior sd = .1)
#impact2d$summary[,"p"]
```

<br>

As seen in the Figure above, the errors in the different models were very similar. However, some exhibited lower cumulative errors.

<br>

```{r summary_of_models, echo=T, cache= T, paged.print=TRUE, warning=T,eval=T}
summary<-cbind(Models=c("No control variables(a)",
                          "Control variables(b)",
                          "a, LocalLinearTrend",
                          "b, LocalLinearTrend",
                          "a, LocalLinearTrend & AR",
                          "b, LocalLinearTrend & AR",                          
                          "a, Prior sd=.1",
                          "b, Prior sd=.1",
                          "a, Prior sd=.1, LocalLinearTrend",
                          "b, Prior sd=.1, LocalLinearTrend",
                          "a, Prior sd=.1, LocalLinearTrend & AR",
                          "b, Prior sd=.1, LocalLinearTrend & AR",
                          "a, Student Dist, Prior sd=.01",
                          "b, Student Dist, Prior sd=.01",
                          "a, Student Dist, Prior sd=.01, LocalLinearTrend",
                          "b, Student Dist, Prior sd=.01, LocalLinearTrend",
                          "a, Student Dist, Prior sd=.01, LocalLinearTrend & AR",
                          "b, Student Dist, Prior sd=.01, LocalLinearTrend & AR",
                          "a, Student Dist, Prior sd=.1",
                          "b, Student Dist, Prior sd=.1",
                          "a, Student Dist, Prior sd=.1, LocalLinearTrend",
                          "b, Student Dist, Prior sd=.1, LocalLinearTrend",
                          "a, Student Dist, Prior sd=.1, LocalLinearTrend & AR",
                          "b, Student Dist, Prior sd=.1, LocalLinearTrend & AR"),
               name=c("impact2","impact3","impact2b","impact3b","impact2bar","impact3bar","impact2c","impact3c","impact2c3","impact3c3","impact2c3ar","impact3c3ar","impact2d1","impact3d1","impact2d2","impact2d2ar","impact3d2","impact3d2ar","impact2d","impact3d","impact2d3","impact3d3","impact2d3ar","impact3d3ar"),
  `_`= rbind(    
                        data.table(impact2$summary,keep.rownames = T)[1,],
                        data.table(impact3$summary,keep.rownames = T)[1,],
                        data.table(impact2b$summary,keep.rownames = T)[1,],
                        data.table(impact3b$summary,keep.rownames = T)[1,],
                        data.table(impact2bar$summary,keep.rownames = T)[1,],
                        data.table(impact3bar$summary,keep.rownames = T)[1,],
                        data.table(impact2c$summary,keep.rownames = T)[1,],
                        data.table(impact3c$summary,keep.rownames = T)[1,],
                        data.table(impact2c3$summary,keep.rownames = T)[1,],
                        data.table(impact3c3$summary,keep.rownames = T)[1,],
                        data.table(impact2c3ar$summary,keep.rownames = T)[1,],
                        data.table(impact3c3ar$summary,keep.rownames = T)[1,],
                        data.table(impact2d1$summary,keep.rownames = T)[1,],
                        data.table(impact3d1$summary,keep.rownames = T)[1,],
                        data.table(impact2d2$summary,keep.rownames = T)[1,],
                        data.table(impact2d2ar$summary,keep.rownames = T)[1,],
                        data.table(impact3d2$summary,keep.rownames = T)[1,],
                        data.table(impact3d2ar$summary,keep.rownames = T)[1,],
                        data.table(impact2d$summary,keep.rownames = T)[1,],
                        data.table(impact3d$summary,keep.rownames = T)[1,],
                        data.table(impact2d3$summary,keep.rownames = T)[1,],
                        data.table(impact3d3$summary,keep.rownames = T)[1,],
                        data.table(impact2d3ar$summary,keep.rownames = T)[1,],
                        data.table(impact3d3ar$summary,keep.rownames = T)[1,]
             ))%>% data.table(.,keep.rownames = F)

#comp_mod_df_sum[,c("Models","name","mean_tot")]
  summary%>%
    rename_all(~sub('_.', '', .x))%>%
    dplyr::mutate_at(4:(ncol(.)-1),~round(as.numeric(.),2)) %>% 
    dplyr::mutate_at(ncol(.),~round(as.numeric(.),4)) %>% 
   # dplyr::rename_at(vars(starts_with('X_')),~
  knitr::kable(format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 1. Summary of the effects of the different models",
                 align =c('l',rep('c', 101)))%>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
```

<br>

```{r comparison_of_errors, echo=T, cache= T, paged.print=TRUE, warning=T,eval=T}
comp_mod_df_sum<-
  comp_mod_df_sum %>% 
    dplyr::filter(grepl("^a,", Models)|grepl("\\(a,", Models)) %>% 
    dplyr::left_join(summary[,c("Models","name")],by="Models") 

comp_mod_df_sum %>% 
  dplyr::filter(grepl("^a,", Models)) %>% 
  dplyr::select( Models, mean, median, p25, p75, mean_tot, max) %>% 
    dplyr::mutate_at(2:(ncol(.)-1),~round(as.numeric(.),2)) %>% 
      dplyr::mutate_at(ncol(.),~round(as.numeric(.),0)) %>% 
    #dplyr::arrange(Models,rn) %>% 
   # dplyr::rename_at(vars(starts_with('X_')),~rstudio
  knitr::kable(format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 2. Standardized Comparison of Estimated Models",
               col.names=c("Models", "Mean (Std. z scale)","Median (z scale)", "Q1 (z scale)", "Q3 (z scale)",
                           "Total Average (z scale)","Maximum CAFE"),
                 align =c('l',rep('c', 101)))%>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
```

## Selected Model

<br>

For the meantime, we selected the model with the lowest cumulative errors, which assumes a Studentized distribution and a standard deviation of .1 and .01 in the priors.

<br>

```{r bsts_model_selected2, echo=T, cache= T, paged.print=TRUE, warning=F}
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
invisible(c("'0b, Student Dist, Prior sd=.01' = model2d1, #Student SD=.1 Local           'b, Student Dist, Prior sd=.1' = model2d,"))

cat("#### ",as.character(comp_mod_df_sum[1,c("Models")]),"\n")
summary(get(as.character(comp_mod_df_sum[1,c("name")]))) 

cat("#### ",as.character(comp_mod_df_sum[2,c("Models")]),"\n")
summary(get(as.character(comp_mod_df_sum[2,c("name")])))

#The “Average” column represents the average across time during the post-intervention period, while the “Cumulative” column presents the total sum of the time points. In particular, looking at the Average Absolute effect, we see that it is estimated to be 22, with a 95% posterior interval between -38 to -5. Since the interval excludes 0, we can conclude that the intervention of the Public Health Emergency in Los Angeles had a causal impact on the PM2.5 air quality with certain assumptions.
```

<br>

```{=html}
<!--- 
Generally, we can write a Bayesian structural model like this:

$$ Y_t = \mu_t + x_t \beta + S_t + e_t, e_t \sim N(0, \sigma^2_e) $$
$$ \mu_{t+1} = \mu_t + \nu_t, \nu_t \sim N(0, \sigma^2_{\nu}). $$
--->
```

<br>

# References

-   Cox, L. (2015) Quantifying and Reducing Uncertainty about Causality in Improving Public Health and Safety. In: Ghanem R., Higdon D., Owhadi H. (eds) Handbook of Uncertainty Quantification. Springer, Cham. <https://doi.org/10.1007/978-3-319-11259-6_71-1>

-   Brodersen, KH., Gallusser, F., Koehler, J., Remy, N., Scott, SL. (2015) Inferring causal impact using Bayesian structural time-series models. Ann Appl Stat 9:247-274
